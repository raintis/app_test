/*
 * PRELYTIS.
 * Copyright 2007, PRELYTIS S.A., and individual contributors
 * as indicated by the @author tags. See the copyright.txt file in the
 * distribution for a full listing of individual contributors.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */
 
options{
   IGNORE_CASE=true ;
   STATIC=false;
   MULTI=true;
}

PARSER_BEGIN(SqlGrammar)
package org.jdbc4olap.parsing;

import java.io.*;
import java.util.*;

public class SqlGrammar {
}

PARSER_END(SqlGrammar)

SKIP:
{
   " "
|   "\t"
|   "\r"
|   "\n"
|   "("
|   ")"
}

TOKEN: /* SQL Keywords*/
{
   <K_ALL: "ALL">
|   <K_AND: "AND">
|   <K_ANY: "ANY">
|   <K_AS: "AS">
|   <K_ASC:"ASC">
|   <K_AVG:"AVG">
|   <K_BETWEEN:"BETWEEN">
|   <K_BINARY_INTEGER: "BINARY_INTEGER">
|   <K_BOOLEAN:"BOOLEAN">
|   <K_BY:"BY">
|   <K_CHAR:"CHAR">
|   <K_COMMENT:"COMMENT">
|   <K_COMMIT:"COMMIT">
|   <K_CONNECT:"CONNECT">
|   <K_COUNT:"COUNT">
|   <K_DATE:"DATE">
|   <K_DELETE:"DELETE">
|   <K_DESC:"DESC">
|   <K_DISTINCT:"DISTINCT">
|   <K_EXCLUSIVE:"EXCLUSIVE">
|   <K_EXISTS:"EXISTS">
|   <K_EXIT:"EXIT">
|   <K_FLOAT:"FLOAT">
|   <K_FOR:"FOR">
|   <K_FROM:"FROM">
|   <K_GROUP:"GROUP">
|   <K_HAVING:"HAVING">
|   <K_IN:"IN">
|   <K_INSERT:"INSERT">
|   <K_INTEGER:"INTEGER">
|   <K_INTERSECT:"INTERSECT">
|   <K_INTO:"INTO">
|   <K_IS:"IS">
|   <K_LIKE:"LIKE">
|   <K_LOCK:"LOCK">
|   <K_MAX:"MAX">
|   <K_MIN:"MIN">
|   <K_MINUS:"MINUS">
|   <K_MODE:"MODE">
|   <K_NATURAL:"NATURAL">
|   <K_NOT:"NOT">
|   <K_NOWAIT:"NOWAIT">
|   <K_NULL:"NULL">
|   <K_NUMBER:"NUMBER">
|   <K_OF:"OF">
|   <K_ONLY:"ONLY">
|   <K_OR:"OR">
|   <K_ORDER:"ORDER">
|   <K_PRIOR:"PRIOR">
|   <K_QUIT:"QUIT">
|   <K_READ:"READ">
|   <K_REAL:"REAL">
|   <K_ROLLBACK:"ROLLBACK">
|   <K_ROW:"ROW">
|   <K_SELECT:"SELECT">
|   <K_SET:"SET">
|   <K_SHARE:"SHARE">
|   <K_SMALLINT:"SMALLINT">
|   <K_START:"START">
|   <K_SUM:"SUM">
|   <K_TABLE:"TABLE">
|   <K_TRANSACTION:"TRANSACTION">
|   <K_UNION:"UNION">
|   <K_UPDATE:"UPDATE">
|   <K_VALUES:"VALUES">
|   <K_VARCHAR2:"VARCHAR2">
|   <K_VARCHAR:"VARCHAR">
|   <K_WHERE:"WHERE">
|   <K_WITH:"WITH">
|   <K_WORK:"WORK">
|   <K_WRITE:"WRITE">
}

TOKEN : /* Numeric Constants */
{
       < S_NUMBER: <FLOAT>
           | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?
       >
 |     < #FLOAT: <INTEGER>
           | <INTEGER> ( "." <INTEGER> )?
           | "." <INTEGER>
       >
 |     < #INTEGER: ( <DIGIT> )+ >
 |     < #DIGIT: ["0" - "9"] >
}

SPECIAL_TOKEN:
{
  <LINE_COMMENT: "--"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN:
{
       < S_IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
|       < #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: "$" | "_">
|   < S_BIND: ":" <S_IDENTIFIER> ("." <S_IDENTIFIER>)? >
|   < S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
|   < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

SimpleNode QueryStatement() #Query:
{ }
{
 "SELECT" 
 SelectList()
 FromClause()
 [ "WHERE" WhereClause() ]
 [ GroupByClause() ]
 [";"]
 { return jjtThis; }
}

// SelectList ::= * | SelectItem (, SelectItem)*
void SelectList() #SelectList:
{ Token t; }
{
 t= "*" { jjtThis.setText(t.image); }
 |
 SelectItem() { }
 ("," SelectItem() { } #SelectList(2) )*
 { }
}

// SelectItem() ::= SelectStar | ColumnName() [SelectAlias]
void SelectItem() #SelectItem:
{  }
{
   LOOKAHEAD(SelectStar()) SelectStar() { }
 | 
   ColumnName()
   { }
   [ SelectAlias() { } #SelectAliasItem(2)] // Column Alias
   { }
}

// SelectStar() ::= OracleObjectName()".*"
void SelectStar():
{ }
{
 OracleObjectName()".*" { } // tableName.* or tableAlias.*
}

void ColumnName() #ColumnName:
{ }
{
   LOOKAHEAD(TableReference()) TableReference() { } //catalog.schema.table.column
   "." OracleObjectName() { } #CompleteTableColumnName(2)
|   OracleObjectName() { } // tableName.column or tableAlias.column or column
   [ "." OracleObjectName() { } #TableColumnName(2)]
}

// SelectAlias ::= (<S_IDENTIFIER>)+
void SelectAlias() #SelectAlias:
{ Token t; }
{
 [ "AS" ] t=<S_IDENTIFIER> { jjtThis.setText(t.image);   }
 { }
}

void CatalogName():
{ }
{
   OracleObjectName() { }
}

void SchemaName():
{ }
{
   OracleObjectName() { }
}

void TableName():
{ }
{
   OracleObjectName() { }
}

void OracleObjectName():
{ Token t; }
{
  t= <S_IDENTIFIER> { jjtThis.setText(t.image); } 
| t= <S_QUOTED_IDENTIFIER> { jjtThis.setText(t.image); }
}

// FromClause ::= FromItem (, FromItem)*
void FromClause():
{ }
{
   "FROM" FromItem() { }
   ( "," FromItem() { } #FromClause(2))*
   { }
}

void TableReference():
{}
{
 CatalogName() { }
 "." SchemaName() { }
 "." TableName() { }  	
}

// FromItem ::= TableReference [alias]
void FromItem():
{ }
{
 TableReference()   
 [ TableAlias() #FromAliasItem(2)]  /* Alias Name */
 { }
}

// TableAlias ::= (<S_IDENTIFIER>)+
void TableAlias() #TableAlias:
{ Token t; }
{
 t=<S_IDENTIFIER> { jjtThis.setText(t.image);   }
 { }
}

void WhereClause():
{ }
{
SQLRelationalExpression()
[ "AND" WhereClause() #WhereClause(2) ]
{}
}

void SQLRelationalExpression():
{ }
{
 SQLSimpleExpression() { }
 ( SQLRelationalOperatorExpression() #SQLRelOpExpr(2)
  |  LOOKAHEAD(2) (SQLInClause() #SQLInExpr(2)))
 { }
}

void SQLRelationalOperatorExpression():
{ }
{
  Relop() { }
  SQLSimpleExpression() { }
   { }
}

void SQLSimpleExpression():
{ Token t; }
{
  ColumnName() { }
|  t=<S_NUMBER> { jjtThis.setText(t.image); }
|  t=<S_CHAR_LITERAL> { jjtThis.setText(t.image); }
|  t="?" { jjtThis.setText(t.image); }
}

void Relop():
{ Token t; }
{
  t="="  {jjtThis.setText(t.image); }
 | t="!=" { jjtThis.setText(t.image);}
 | t="<>" { jjtThis.setText(t.image);}
 | t=">"  {jjtThis.setText(t.image); }
 | t=">=" {jjtThis.setText(t.image); }
 | t="<"  {jjtThis.setText(t.image); }
 | t="<=" {jjtThis.setText(t.image); }
// | "#"  { }
}

void SQLExpressionList():
{ }
{
  SQLSimpleExpression() { }
  ("," SQLSimpleExpression() { } )*
  { }
}

void SQLInClause():
{ }
{
 "IN" { }
 SQLExpressionList() { }
 { }
}

void GroupByClause():
{ }
{
 "GROUP" "BY" SQLExpressionList() { }
 { }
}

